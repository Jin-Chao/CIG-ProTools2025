#! /usr/bin/env python3

import os
import sys
import subprocess
import time
import re
import json
from collections import defaultdict
import argparse

# Configuration
PROJ_PATH = "./Himeno"
BIN_PATH = os.path.join(PROJ_PATH, "bin")  # used only for listing
SIZE_CFG = "-s"
LOOP_CFG = "-l"
TASK_CMD = "taskset"
TASK_CORE = "-c"
REPEAT = 5

# Input sizes
sizes = [["S", "1000"], ["M", "1000"], ["L", "100"], ["XL", "10"]]

# Regex
MFLOPS_PATTERN = r"MFLOPS measured\s*:\s*([0-9]+(?:\.[0-9]+)?)"

# Results: perf_results[opt][exe][size] = [(mflops, time), ...]
perf_results = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

def get_default_core():
    try:
        # Available CPU IDs (Linux only)
        cores = sorted(os.sched_getaffinity(0))
        return cores[len(cores) // 2] if cores else 0
    except AttributeError:
        # Fallback: assume 4 cores
        return 2

def parse_executables(bin_dir):
    """
    Returns: dict { opt: [exe paths] }, and map of exe path to (base, opt)
    """
    exe_map = defaultdict(list)
    exe_meta = {}
    for fname in os.listdir(bin_dir):
        full_path = os.path.join(bin_dir, fname)
        if os.path.isfile(full_path) and '.' in fname:
            base, opt = fname.rsplit(".", 1)
            exe_map[opt].append(full_path)
            exe_meta[full_path] = (base, opt)
    return exe_map, exe_meta

def run(core_id, bin_dir=BIN_PATH):
    exe_map, exe_meta = parse_executables(bin_dir)
    for opt, paths in exe_map.items():
        for path in paths:
            base, _ = exe_meta[path]
            for size in sizes:
                for i in range(REPEAT):
                    cmd = [TASK_CMD, TASK_CORE, str(core_id), path, SIZE_CFG, size[0], LOOP_CFG, size[1]]
                    print(cmd)
                    start = time.time()
                    try:
                        res = subprocess.run(cmd, capture_output=True, text=True)
                    except FileNotFoundError as e:
                        print(f"ERROR: {e}")
                        continue
                    elapsed = time.time() - start

                    print(" ".join(res.args))
                    print(res.stdout)
                    print(res.stderr)

                    m = re.search(MFLOPS_PATTERN, res.stdout)
                    if m:
                        mflops = float(m.group(1))
                        perf_results[opt][base][size[0]].append((mflops, elapsed))
                    else:
                        print(f"ERROR: MFLOPS not found for {path} size {size}")

def print_results():
    for opt, exe_dict in perf_results.items():
        print(f"\n=== Optimization: {opt} ===")
        for exe, size_dict in exe_dict.items():
            print(f"{exe}")
            for sz, runs in size_dict.items():
                print(f"  {sz}:")
                for mflops, elapsed in runs:
                    print(f"    MFLOPS: {mflops:.2f}, Time: {elapsed:.3f}s")

def write_json_files(output):
    for opt, exe_dict in perf_results.items():
        results = {
            exe: {size: [list(run) for run in runs] for size, runs in size_dict.items()}
            for exe, size_dict in exe_dict.items()
        }
        json_file = f"{output}_{opt}.json"
        with open(json_file, "w") as f:
            json.dump(results, f, indent=2)
        print(f"[+] Written: {json_file}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run Himeno benchmarks with different sizes using core binding and JSON output.")
    parser.add_argument("--core", type=int, help="Bind execution to a specific CPU core. If not specified, the middle core is used.")
    parser.add_argument("--output", type=str, help="Path to save output JSON file.")
    args = parser.parse_args()

    core = args.core if args.core is not None else get_default_core()
    print(f"Running benchmarks on core {core}")
    run(core)
    print_results()
    write_json_files(args.output)
